# Shortpaths

Resilient file path aliases.

**Note** Currently Shortpaths is good enough to work with in practice,
but the program is far from perfect and requires some more work to be
better.

## Rationale

If you want to refer to on disk file paths but want them to be available to all
your favorite applications, or if you don't want to change a significant number of
broken/missing/unreachable path aliases when they inevitably move, then shortpaths
is for you.

## Features

- Resilience: Shortpaths are designed to almost never break/be unreachable.
- Nested shortpath definitions. Shortpaths can contain other shortpaths in their filename.
    This further improves resilience by making it efficient to modify one shortpath.
    If a shortpath is found to be unreachable, then it can be easily remedied by updating one shortpath instead of many files paths for nested files.
- Universal: Shortpaths can export shell alias completions and also be embedded for use in applications.
- Ease of Use: Adding new shortpaths is as easy as `shortpath add [name] [path]`
- Centralization: All your shortpaths are stored in one file for you to view
- Better Security: Your shortpaths config is only editable by you. In the case of
    bash completions, you can be sure the completions file generated by shortpaths is secure.

## How It Works

Shortpaths make use of a database with an `update()` function
as well as shell script shadowed functions to ensure that paths are always maintained.

When a path is unreachable, directories are searched from the current directory and
up every parent directory until it is found. If it is not found then shortpaths
will error out and notify the user that the path could not be found.

If a directory is deleted, `shortpaths remove` is called and when a
path is moved then `shortpaths update` is called instead.

Shortpaths also exports shell completions for you to use so you
can make use of its power.


<!--Security:-->
<!--- The shortpaths file can only be edited by the current user.-->
<!--- Certain shortpaths can be refrained from being edited/removed or checked with the `const: true` property-->

<!--Commands-->
<!--- add, remove, update, check-->

<!--These commands will correspond to various operations such as:-->
<!--mv -> update-->
<!--rm -> remove-->

Benefits over using shell variables

## Usage

```bash
# Adds a new shortpath
shortpath add "name" "path"

# Removes a shortpath
shortpath remove -n "name" # Remove by name
shortpath remove -p "path" # Remove by path

# Checks all available shortpaths for missing/unreachable paths
# If the path is missing, warn the user
shortpath check

# Like check but performs the shortpath auto migration
shortpath autoindex

# Update a shortpath
shortpath update "current_name" -n "new_name" # Renames shortpath
shortpath update "current_name" -p "new_path" # Update shortpath directory

# Exports shell completions
shortpath export bash       # Bash completions
shortpath export powershell # Powershell completions
```


## Shell Completions

### Bash

If you'd like to get resilient shortpath completions for bash, add the following to your `.bashrc`:

```bash
mv() {
    # TODO
}

rm() {
    # TODO
}
```

Generate and source the shell completions with:

```bash
# TODO: Make install script to install bash/powershell completions
cargo b
mv target/completions/shortpath.bash /usr/share/bash-completion/completions
```

### Powershell

To get resilient completions for powershell, add the following to your `$profile`:

```ps1
move() {
    # TODO
}

remove() {
    # TODO
}
```

Generate and source the shell completions with:

```bash
cargo b
mv target/completions/shortpath.ps1 $profile/shortpath.ps1
```

## TODO

The ordering of the shortpaths in which they are determined is still an issue.
Similar dependent path groups should be grouped together. That is,
    - If two path groups contain intersecting dependencies, they should be grouped first.
        Then the path groups should be determined from alphabetical order.
    - If one path is dependent on another path, that path should be defined first.

- Order path strings by similarity.
- Profile/benchmark shortpaths
    - Benches crate?
- Write a few unit tests to assert functionality

## Considered
- Look into `tracing` library.

### Backburner
- Generate shell completions for shortpaths (cli)
- Generate man pages for shortpaths (cli)
- Export powershell completions
- Create and Complete Documentation
